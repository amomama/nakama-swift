// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///*
/// The Nakama server RPC protocol for games and apps.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A user with additional account details. Always the current user.
struct Nakama_Api_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user object.
  var user: Nakama_Api_User {
    get {return _storage._user ?? Nakama_Api_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// The user's wallet data.
  var wallet: String {
    get {return _storage._wallet}
    set {_uniqueStorage()._wallet = newValue}
  }

  /// The email address of the user.
  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  /// The devices which belong to the user's account.
  var devices: [Nakama_Api_AccountDevice] {
    get {return _storage._devices}
    set {_uniqueStorage()._devices = newValue}
  }

  /// The custom id in the user's account.
  var customID: String {
    get {return _storage._customID}
    set {_uniqueStorage()._customID = newValue}
  }

  /// The UNIX time when the user's email was verified.
  var verifyTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._verifyTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._verifyTime = newValue}
  }
  /// Returns true if `verifyTime` has been explicitly set.
  var hasVerifyTime: Bool {return _storage._verifyTime != nil}
  /// Clears the value of `verifyTime`. Subsequent reads from it will return its default value.
  mutating func clearVerifyTime() {_uniqueStorage()._verifyTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Send a custom ID to the server. Used with authenticate/link/unlink.
struct Nakama_Api_AccountCustom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A custom identifier.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send a device to the server. Used with authenticate/link/unlink and user.
struct Nakama_Api_AccountDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A device identifier. Should be obtained by a platform-specific device API.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send an email with password to the server. Used with authenticate/link/unlink.
struct Nakama_Api_AccountEmail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A valid RFC-5322 email address.
  var email: String = String()

  /// A password for the user account.
  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send a Facebook token to the server. Used with authenticate/link/unlink.
struct Nakama_Api_AccountFacebook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The OAuth token received from Facebook to access their profile API.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
struct Nakama_Api_AccountGameCenter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Player ID (generated by GameCenter).
  var playerID: String = String()

  /// Bundle ID (generated by GameCenter).
  var bundleID: String = String()

  /// Time since UNIX epoch when the signature was created.
  var timestampSeconds: Int64 = 0

  /// A random "NSString" used to compute the hash and keep it randomized.
  var salt: String = String()

  /// The verification signature data generated.
  var signature: String = String()

  /// The URL for the public encryption key.
  var publicKeyURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send a Google token to the server. Used with authenticate/link/unlink.
struct Nakama_Api_AccountGoogle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The OAuth token received from Google to access their profile API.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send a Steam token to the server. Used with authenticate/link/unlink.
struct Nakama_Api_AccountSteam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account token received from Steam to access their profile API.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Add one or more friends to the current user.
struct Nakama_Api_AddFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  var ids: [String] = []

  /// The account username of a user.
  var usernames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Add users to a group.
struct Nakama_Api_AddGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group to add users to.
  var groupID: String = String()

  /// The users to add.
  var userIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Authenticate against the server with a custom ID.
struct Nakama_Api_AuthenticateCustomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The custom account details.
  var account: Nakama_Api_AccountCustom {
    get {return _storage._account ?? Nakama_Api_AccountCustom()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Authenticate against the server with a device ID.
struct Nakama_Api_AuthenticateDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device account details.
  var account: Nakama_Api_AccountDevice {
    get {return _storage._account ?? Nakama_Api_AccountDevice()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Authenticate against the server with email+password.
struct Nakama_Api_AuthenticateEmailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The email account details.
  var account: Nakama_Api_AccountEmail {
    get {return _storage._account ?? Nakama_Api_AccountEmail()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Authenticate against the server with Facebook.
struct Nakama_Api_AuthenticateFacebookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook account details.
  var account: Nakama_Api_AccountFacebook {
    get {return _storage._account ?? Nakama_Api_AccountFacebook()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  /// Import Facebook friends for the user.
  var `import`: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._import ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._import = newValue}
  }
  /// Returns true if ``import`` has been explicitly set.
  var hasImport: Bool {return _storage._import != nil}
  /// Clears the value of ``import``. Subsequent reads from it will return its default value.
  mutating func clearImport() {_uniqueStorage()._import = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Authenticate against the server with Apple's Game Center.
struct Nakama_Api_AuthenticateGameCenterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Game Center account details.
  var account: Nakama_Api_AccountGameCenter {
    get {return _storage._account ?? Nakama_Api_AccountGameCenter()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Authenticate against the server with Google.
struct Nakama_Api_AuthenticateGoogleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google account details.
  var account: Nakama_Api_AccountGoogle {
    get {return _storage._account ?? Nakama_Api_AccountGoogle()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Authenticate against the server with Steam.
struct Nakama_Api_AuthenticateSteamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Steam account details.
  var account: Nakama_Api_AccountSteam {
    get {return _storage._account ?? Nakama_Api_AccountSteam()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Register the account if the user does not already exist.
  var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  var hasCreate: Bool {return _storage._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  mutating func clearCreate() {_uniqueStorage()._create = nil}

  /// Set the username on the account at register. Must be unique.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Block one or more friends for the current user.
struct Nakama_Api_BlockFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  var ids: [String] = []

  /// The account username of a user.
  var usernames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message sent on a channel.
struct Nakama_Api_ChannelMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel this message belongs to.
  var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// The unique ID of this message.
  var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  /// The code representing a message type or category.
  var code: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._code ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  var hasCode: Bool {return _storage._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  mutating func clearCode() {_uniqueStorage()._code = nil}

  /// Message sender, usually a user ID.
  var senderID: String {
    get {return _storage._senderID}
    set {_uniqueStorage()._senderID = newValue}
  }

  /// The username of the message sender, if any.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  /// The content payload.
  var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// The UNIX time when the message was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the message was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// True if the message was persisted to the channel's history, false otherwise.
  var persistent: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._persistent ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._persistent = newValue}
  }
  /// Returns true if `persistent` has been explicitly set.
  var hasPersistent: Bool {return _storage._persistent != nil}
  /// Clears the value of `persistent`. Subsequent reads from it will return its default value.
  mutating func clearPersistent() {_uniqueStorage()._persistent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of channel messages, usually a result of a list operation.
struct Nakama_Api_ChannelMessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of messages.
  var messages: [Nakama_Api_ChannelMessage] = []

  /// The cursor to send when retireving the next page, if any.
  var nextCursor: String = String()

  /// The cursor to send when retrieving the previous page, if any.
  var prevCursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Create a group with the current user as owner.
struct Nakama_Api_CreateGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique name for the group.
  var name: String = String()

  /// A description for the group.
  var description_p: String = String()

  /// The language expected to be a tag which follows the BCP-47 spec.
  var langTag: String = String()

  /// A URL for an avatar image.
  var avatarURL: String = String()

  /// Mark a group as open or not where only admins can accept members.
  var `open`: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Delete one or more friends for the current user.
struct Nakama_Api_DeleteFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  var ids: [String] = []

  /// The account username of a user.
  var usernames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Delete a group the user has access to.
struct Nakama_Api_DeleteGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of a group.
  var groupID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Delete a leaderboard record.
struct Nakama_Api_DeleteLeaderboardRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The leaderboard ID to delete from.
  var leaderboardID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Delete one or more notifications for the current user.
struct Nakama_Api_DeleteNotificationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of notifications.
  var ids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Storage objects to delete.
struct Nakama_Api_DeleteStorageObjectId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  var collection: String = String()

  /// The key of the object within the collection.
  var key: String = String()

  /// The version hash of the object.
  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Batch delete storage objects.
struct Nakama_Api_DeleteStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch of storage objects.
  var objectIds: [Nakama_Api_DeleteStorageObjectId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A friend of a user.
struct Nakama_Api_Friend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user object.
  var user: Nakama_Api_User {
    get {return _storage._user ?? Nakama_Api_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// The friend status.
  var state: Int32 {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The friendship status.
  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Default case. Assumed as FRIEND state.
    case unspecified // = 0

    /// The user is a friend of the current user.
    case friend // = 1

    /// The user has sent an invite to the current user.
    case inviteSent // = 2

    /// The current user has sent an invite to this user.
    case inviteReceived // = 3

    /// The current user has blocked this user.
    case blocked // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .friend
      case 2: self = .inviteSent
      case 3: self = .inviteReceived
      case 4: self = .blocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .friend: return 1
      case .inviteSent: return 2
      case .inviteReceived: return 3
      case .blocked: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Nakama_Api_Friend.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Nakama_Api_Friend.State] = [
    .unspecified,
    .friend,
    .inviteSent,
    .inviteReceived,
    .blocked,
  ]
}

#endif  // swift(>=4.2)

/// A collection of zero or more friends of the user.
struct Nakama_Api_Friends {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Friend objects.
  var friends: [Nakama_Api_Friend] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Fetch a batch of zero or more users from the server.
struct Nakama_Api_GetUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  var ids: [String] = []

  /// The account username of a user.
  var usernames: [String] = []

  /// The Facebook ID of a user.
  var facebookIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A group in the server.
struct Nakama_Api_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of a group.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The id of the user who created the group.
  var creatorID: String {
    get {return _storage._creatorID}
    set {_uniqueStorage()._creatorID = newValue}
  }

  /// The unique name of the group.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A description for the group.
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The language expected to be a tag which follows the BCP-47 spec.
  var langTag: String {
    get {return _storage._langTag}
    set {_uniqueStorage()._langTag = newValue}
  }

  /// Additional information stored as a JSON object.
  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// A URL for an avatar image.
  var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// Anyone can join open groups, otherwise only admins can accept members.
  var `open`: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._open ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  var hasOpen: Bool {return _storage._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  mutating func clearOpen() {_uniqueStorage()._open = nil}

  /// The current count of all members in the group.
  var edgeCount: Int32 {
    get {return _storage._edgeCount}
    set {_uniqueStorage()._edgeCount = newValue}
  }

  /// The maximum number of members allowed.
  var maxCount: Int32 {
    get {return _storage._maxCount}
    set {_uniqueStorage()._maxCount = newValue}
  }

  /// The UNIX time when the group was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the group was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// One or more groups returned from a listing operation.
struct Nakama_Api_GroupList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One or more groups.
  var groups: [Nakama_Api_Group] = []

  /// A cursor used to get the next page.
  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list of users belonging to a group, along with their role.
struct Nakama_Api_GroupUserList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User-role pairs for a group.
  var groupUsers: [Nakama_Api_GroupUserList.GroupUser] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single user-role pair.
  struct GroupUser {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User.
    var user: Nakama_Api_User {
      get {return _storage._user ?? Nakama_Api_User()}
      set {_uniqueStorage()._user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool {return _storage._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() {_uniqueStorage()._user = nil}

    /// Their relationship to the group.
    var state: Int32 {
      get {return _storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The group role status.
    enum State: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Default case. Assumed as SUPERADMIN state.
      case unspecified // = 0

      /// The user is a superadmin with full control of the group.
      case superadmin // = 1

      /// The user is an admin with additional privileges.
      case admin // = 2

      /// The user is a regular member.
      case member // = 3

      /// The user has requested to join the group
      case joinRequest // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .superadmin
        case 2: self = .admin
        case 3: self = .member
        case 4: self = .joinRequest
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .superadmin: return 1
        case .admin: return 2
        case .member: return 3
        case .joinRequest: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// Import Facebook friends into the current user's account.
struct Nakama_Api_ImportFacebookFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook account details.
  var account: Nakama_Api_AccountFacebook {
    get {return _storage._account ?? Nakama_Api_AccountFacebook()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Reset the current user's friends list.
  var reset: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._reset ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._reset = newValue}
  }
  /// Returns true if `reset` has been explicitly set.
  var hasReset: Bool {return _storage._reset != nil}
  /// Clears the value of `reset`. Subsequent reads from it will return its default value.
  mutating func clearReset() {_uniqueStorage()._reset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Immediately join an open group, or request to join a closed one.
struct Nakama_Api_JoinGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to join.
  var groupID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Kick a set of users from a group.
struct Nakama_Api_KickGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to kick from.
  var groupID: String = String()

  /// The users to kick.
  var userIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a complete leaderboard record with all scores and associated metadata.
struct Nakama_Api_LeaderboardRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the leaderboard this score belongs to.
  var leaderboardID: String {
    get {return _storage._leaderboardID}
    set {_uniqueStorage()._leaderboardID = newValue}
  }

  /// The ID of the score owner, usually a user or group.
  var ownerID: String {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  /// The username of the score owner, if the owner is a user.
  var username: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._username ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return _storage._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {_uniqueStorage()._username = nil}

  /// The score value.
  var score: Int64 {
    get {return _storage._score}
    set {_uniqueStorage()._score = newValue}
  }

  /// An optional subscore value.
  var subscore: Int64 {
    get {return _storage._subscore}
    set {_uniqueStorage()._subscore = newValue}
  }

  /// The number of submissions to this score record.
  var numScore: Int32 {
    get {return _storage._numScore}
    set {_uniqueStorage()._numScore = newValue}
  }

  /// Metadata.
  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// The UNIX time when the leaderboard record was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the leaderboard record was updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// The UNIX time when the leaderboard record expires.
  var expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiryTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  var hasExpiryTime: Bool {return _storage._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  mutating func clearExpiryTime() {_uniqueStorage()._expiryTime = nil}

  /// The rank of this record.
  var rank: Int64 {
    get {return _storage._rank}
    set {_uniqueStorage()._rank = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
struct Nakama_Api_LeaderboardRecordList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of leaderboard records.
  var records: [Nakama_Api_LeaderboardRecord] = []

  /// A batched set of leaderobard records belonging to specified owners.
  var ownerRecords: [Nakama_Api_LeaderboardRecord] = []

  /// The cursor to send when retireving the next page, if any.
  var nextCursor: String = String()

  /// The cursor to send when retrieving the previous page, if any.
  var prevCursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Leave a group.
struct Nakama_Api_LeaveGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to leave.
  var groupID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Link Facebook to the current user's account.
struct Nakama_Api_LinkFacebookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook account details.
  var account: Nakama_Api_AccountFacebook {
    get {return _storage._account ?? Nakama_Api_AccountFacebook()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// Import Facebook friends for the user.
  var `import`: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._import ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._import = newValue}
  }
  /// Returns true if ``import`` has been explicitly set.
  var hasImport: Bool {return _storage._import != nil}
  /// Clears the value of ``import``. Subsequent reads from it will return its default value.
  mutating func clearImport() {_uniqueStorage()._import = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List a channel's message history.
struct Nakama_Api_ListChannelMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel ID to list from.
  var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// Max number of records to return. Between 1 and 100.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// True if listing should be older messages to newer, false if reverse.
  var forward: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._forward ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._forward = newValue}
  }
  /// Returns true if `forward` has been explicitly set.
  var hasForward: Bool {return _storage._forward != nil}
  /// Clears the value of `forward`. Subsequent reads from it will return its default value.
  mutating func clearForward() {_uniqueStorage()._forward = nil}

  /// A pagination cursor, if any.
  var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List groups based on given filters.
struct Nakama_Api_ListGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List groups that contain this value in their names.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional pagination cursor.
  var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  /// Max number of groups to return. Between 1 and 100.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List all users that are part of a group.
struct Nakama_Api_ListGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to list from.
  var groupID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// List leaderboard records from a given leaderboard.
struct Nakama_Api_ListLeaderboardRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the leaderboard to list for.
  var leaderboardID: String {
    get {return _storage._leaderboardID}
    set {_uniqueStorage()._leaderboardID = newValue}
  }

  /// One or more owners to retrieve records for.
  var ownerIds: [String] {
    get {return _storage._ownerIds}
    set {_uniqueStorage()._ownerIds = newValue}
  }

  /// Max number of records to return. Between 1 and 100.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// A next or previous page cursor.
  var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List realtime matches.
struct Nakama_Api_ListMatchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limit the number of returned matches.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// Authoritative or relayed matches.
  var authoritative: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._authoritative ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._authoritative = newValue}
  }
  /// Returns true if `authoritative` has been explicitly set.
  var hasAuthoritative: Bool {return _storage._authoritative != nil}
  /// Clears the value of `authoritative`. Subsequent reads from it will return its default value.
  mutating func clearAuthoritative() {_uniqueStorage()._authoritative = nil}

  /// Label filter.
  var label: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._label ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return _storage._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {_uniqueStorage()._label = nil}

  /// Minimum user count.
  var minSize: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._minSize ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._minSize = newValue}
  }
  /// Returns true if `minSize` has been explicitly set.
  var hasMinSize: Bool {return _storage._minSize != nil}
  /// Clears the value of `minSize`. Subsequent reads from it will return its default value.
  mutating func clearMinSize() {_uniqueStorage()._minSize = nil}

  /// Maximum user count.
  var maxSize: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._maxSize ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._maxSize = newValue}
  }
  /// Returns true if `maxSize` has been explicitly set.
  var hasMaxSize: Bool {return _storage._maxSize != nil}
  /// Clears the value of `maxSize`. Subsequent reads from it will return its default value.
  mutating func clearMaxSize() {_uniqueStorage()._maxSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Get a list of unexpired notifications.
struct Nakama_Api_ListNotificationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of notifications to get. Between 1 and 100.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// A cursor to page through notifications. May be cached by clients to get from point in time forwards.
  var cacheableCursor: String {
    get {return _storage._cacheableCursor}
    set {_uniqueStorage()._cacheableCursor = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List publicly readable storage objects in a given collection.
struct Nakama_Api_ListStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the user.
  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The collection which stores the object.
  var collection: String {
    get {return _storage._collection}
    set {_uniqueStorage()._collection = newValue}
  }

  /// The number of storage objects to list. Between 1 and 100.
  var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// The cursor to page through results from.
  var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List the groups a user is part of, and their relationship to each.
struct Nakama_Api_ListUserGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the user.
  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a realtime match.
struct Nakama_Api_Match {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the match, can be used to join.
  var matchID: String {
    get {return _storage._matchID}
    set {_uniqueStorage()._matchID = newValue}
  }

  /// True if it's an server-managed authoritative match, false otherwise.
  var authoritative: Bool {
    get {return _storage._authoritative}
    set {_uniqueStorage()._authoritative = newValue}
  }

  /// Match label, if any.
  var label: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._label ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return _storage._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {_uniqueStorage()._label = nil}

  /// Current number of users in the match.
  var size: Int32 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of realtime matches.
struct Nakama_Api_MatchList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A number of matches corresponding to a list operation.
  var matches: [Nakama_Api_Match] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A notification in the server.
struct Nakama_Api_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the Notification.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Subject of the notification.
  var subject: String {
    get {return _storage._subject}
    set {_uniqueStorage()._subject = newValue}
  }

  /// Content of the notification in JSON.
  var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Category code for this notification.
  var code: Int32 {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  /// ID of the sender, if a user. Otherwise 'null'.
  var senderID: String {
    get {return _storage._senderID}
    set {_uniqueStorage()._senderID = newValue}
  }

  /// The UNIX time when the notification was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// True if this notification was persisted to the database.
  var persistent: Bool {
    get {return _storage._persistent}
    set {_uniqueStorage()._persistent = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A collection of zero or more notifications.
struct Nakama_Api_NotificationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collection of notifications.
  var notifications: [Nakama_Api_Notification] = []

  /// Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  var cacheableCursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Promote a set of users in a group to the next role up.
struct Nakama_Api_PromoteGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to promote in.
  var groupID: String = String()

  /// The users to promote.
  var userIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Storage objects to get.
struct Nakama_Api_ReadStorageObjectId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  var collection: String = String()

  /// The key of the object within the collection.
  var key: String = String()

  /// The user owner of the object.
  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Batch get storage objects.
struct Nakama_Api_ReadStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch of storage objects.
  var objectIds: [Nakama_Api_ReadStorageObjectId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Execute an Lua function on the server.
struct Nakama_Api_Rpc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of the function.
  var id: String = String()

  /// The payload of the function which must be a JSON object.
  var payload: String = String()

  /// The authentication key used when executed as a non-client HTTP request.
  var httpKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A user's session used to authenticate messages.
struct Nakama_Api_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the corresponding account was just created, false otherwise.
  var created: Bool = false

  /// Authentication credentials.
  var token: String = String()

  /// rUDP specific authentication credentials.
  var udpToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An object within the storage engine.
struct Nakama_Api_StorageObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  var collection: String {
    get {return _storage._collection}
    set {_uniqueStorage()._collection = newValue}
  }

  /// The key of the object within the collection.
  var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// The user owner of the object.
  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The value of the object.
  var value: String {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// The version hash of the object.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The read access permissions for the object.
  var permissionRead: Int32 {
    get {return _storage._permissionRead}
    set {_uniqueStorage()._permissionRead = newValue}
  }

  /// The write access permissions for the object.
  var permissionWrite: Int32 {
    get {return _storage._permissionWrite}
    set {_uniqueStorage()._permissionWrite = newValue}
  }

  /// The UNIX time when the object was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the object was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A storage acknowledgement.
struct Nakama_Api_StorageObjectAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  var collection: String = String()

  /// The key of the object within the collection.
  var key: String = String()

  /// The version hash of the object.
  var version: String = String()

  /// The owner of the object.
  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Batch of acknowledgements for the storage object write.
struct Nakama_Api_StorageObjectAcks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch of storage write acknowledgements.
  var acks: [Nakama_Api_StorageObjectAck] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Batch of storage objects.
struct Nakama_Api_StorageObjects {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The batch of storage objects.
  var objects: [Nakama_Api_StorageObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// List of storage objects.
struct Nakama_Api_StorageObjectList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of storage objects.
  var objects: [Nakama_Api_StorageObject] = []

  /// The cursor associated with the query a page of results.
  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Update a user's account details.
struct Nakama_Api_UpdateAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The username of the user's account.
  var username: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._username ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return _storage._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {_uniqueStorage()._username = nil}

  /// The display name of the user.
  var displayName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._displayName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return _storage._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {_uniqueStorage()._displayName = nil}

  /// A URL for an avatar image.
  var avatarURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._avatarURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._avatarURL = newValue}
  }
  /// Returns true if `avatarURL` has been explicitly set.
  var hasAvatarURL: Bool {return _storage._avatarURL != nil}
  /// Clears the value of `avatarURL`. Subsequent reads from it will return its default value.
  mutating func clearAvatarURL() {_uniqueStorage()._avatarURL = nil}

  /// The language expected to be a tag which follows the BCP-47 spec.
  var langTag: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._langTag ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._langTag = newValue}
  }
  /// Returns true if `langTag` has been explicitly set.
  var hasLangTag: Bool {return _storage._langTag != nil}
  /// Clears the value of `langTag`. Subsequent reads from it will return its default value.
  mutating func clearLangTag() {_uniqueStorage()._langTag = nil}

  /// The location set by the user.
  var location: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._location ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// The timezone set by the user.
  var timezone: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._timezone ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._timezone = newValue}
  }
  /// Returns true if `timezone` has been explicitly set.
  var hasTimezone: Bool {return _storage._timezone != nil}
  /// Clears the value of `timezone`. Subsequent reads from it will return its default value.
  mutating func clearTimezone() {_uniqueStorage()._timezone = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Update fields in a given group.
struct Nakama_Api_UpdateGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the group to update.
  var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// Name.
  var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// Description string.
  var description_p: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._description_p ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return _storage._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {_uniqueStorage()._description_p = nil}

  /// Lang tag.
  var langTag: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._langTag ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._langTag = newValue}
  }
  /// Returns true if `langTag` has been explicitly set.
  var hasLangTag: Bool {return _storage._langTag != nil}
  /// Clears the value of `langTag`. Subsequent reads from it will return its default value.
  mutating func clearLangTag() {_uniqueStorage()._langTag = nil}

  /// Avatar URL.
  var avatarURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._avatarURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._avatarURL = newValue}
  }
  /// Returns true if `avatarURL` has been explicitly set.
  var hasAvatarURL: Bool {return _storage._avatarURL != nil}
  /// Clears the value of `avatarURL`. Subsequent reads from it will return its default value.
  mutating func clearAvatarURL() {_uniqueStorage()._avatarURL = nil}

  /// Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
  var `open`: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._open ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  var hasOpen: Bool {return _storage._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  mutating func clearOpen() {_uniqueStorage()._open = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A user in the server.
struct Nakama_Api_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user's account.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The username of the user's account.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  /// The display name of the user.
  var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// A URL for an avatar image.
  var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// The language expected to be a tag which follows the BCP-47 spec.
  var langTag: String {
    get {return _storage._langTag}
    set {_uniqueStorage()._langTag = newValue}
  }

  /// The location set by the user.
  var location: String {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  /// The timezone set by the user.
  var timezone: String {
    get {return _storage._timezone}
    set {_uniqueStorage()._timezone = newValue}
  }

  /// Additional information stored as a JSON object.
  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// The Facebook id in the user's account.
  var facebookID: String {
    get {return _storage._facebookID}
    set {_uniqueStorage()._facebookID = newValue}
  }

  /// The Google id in the user's account.
  var googleID: String {
    get {return _storage._googleID}
    set {_uniqueStorage()._googleID = newValue}
  }

  /// The Apple Game Center in of the user's account.
  var gamecenterID: String {
    get {return _storage._gamecenterID}
    set {_uniqueStorage()._gamecenterID = newValue}
  }

  /// The Steam id in the user's account.
  var steamID: String {
    get {return _storage._steamID}
    set {_uniqueStorage()._steamID = newValue}
  }

  /// Indicates whether the user is currently online.
  var online: Bool {
    get {return _storage._online}
    set {_uniqueStorage()._online = newValue}
  }

  /// Number of related edges to this user.
  var edgeCount: Int32 {
    get {return _storage._edgeCount}
    set {_uniqueStorage()._edgeCount = newValue}
  }

  /// The UNIX time when the user was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the user was last updated.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of groups belonging to a user, along with the user's role in each group.
struct Nakama_Api_UserGroupList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Group-role pairs for a user.
  var userGroups: [Nakama_Api_UserGroupList.UserGroup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single group-role pair.
  struct UserGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Group.
    var group: Nakama_Api_Group {
      get {return _storage._group ?? Nakama_Api_Group()}
      set {_uniqueStorage()._group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    var hasGroup: Bool {return _storage._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    mutating func clearGroup() {_uniqueStorage()._group = nil}

    /// The user's relationship to the group.
    var state: Int32 {
      get {return _storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The group role status.
    enum State: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Default case. Assumed as SUPERADMIN state.
      case unspecified // = 0

      /// The user is a superadmin with full control of the group.
      case superadmin // = 1

      /// The user is an admin with additional privileges.
      case admin // = 2

      /// The user is a regular member.
      case member // = 3

      /// The user has requested to join the group
      case joinRequest // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .superadmin
        case 2: self = .admin
        case 3: self = .member
        case 4: self = .joinRequest
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .superadmin: return 1
        case .admin: return 2
        case .member: return 3
        case .joinRequest: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// A collection of zero or more users.
struct Nakama_Api_Users {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The User objects.
  var users: [Nakama_Api_User] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A request to submit a score to a leaderboard.
struct Nakama_Api_WriteLeaderboardRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the leaderboard to write to.
  var leaderboardID: String {
    get {return _storage._leaderboardID}
    set {_uniqueStorage()._leaderboardID = newValue}
  }

  /// Record data.
  var record: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite {
    get {return _storage._record ?? Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite()}
    set {_uniqueStorage()._record = newValue}
  }
  /// Returns true if `record` has been explicitly set.
  var hasRecord: Bool {return _storage._record != nil}
  /// Clears the value of `record`. Subsequent reads from it will return its default value.
  mutating func clearRecord() {_uniqueStorage()._record = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Record values to write.
  struct LeaderboardRecordWrite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The score value to submit.
    var score: Int64 = 0

    /// An optional secondary value.
    var subscore: Int64 = 0

    /// Optional record metadata.
    var metadata: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The object to store.
struct Nakama_Api_WriteStorageObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection to store the object.
  var collection: String {
    get {return _storage._collection}
    set {_uniqueStorage()._collection = newValue}
  }

  /// The key for the object within the collection.
  var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// The value of the object.
  var value: String {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The read access permissions for the object.
  var permissionRead: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._permissionRead ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._permissionRead = newValue}
  }
  /// Returns true if `permissionRead` has been explicitly set.
  var hasPermissionRead: Bool {return _storage._permissionRead != nil}
  /// Clears the value of `permissionRead`. Subsequent reads from it will return its default value.
  mutating func clearPermissionRead() {_uniqueStorage()._permissionRead = nil}

  /// The write access permissions for the object.
  var permissionWrite: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._permissionWrite ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._permissionWrite = newValue}
  }
  /// Returns true if `permissionWrite` has been explicitly set.
  var hasPermissionWrite: Bool {return _storage._permissionWrite != nil}
  /// Clears the value of `permissionWrite`. Subsequent reads from it will return its default value.
  mutating func clearPermissionWrite() {_uniqueStorage()._permissionWrite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Write objects to the storage engine.
struct Nakama_Api_WriteStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The objects to store on the server.
  var objects: [Nakama_Api_WriteStorageObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nakama.api"

extension Nakama_Api_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "wallet"),
    3: .same(proto: "email"),
    4: .same(proto: "devices"),
    5: .standard(proto: "custom_id"),
    6: .standard(proto: "verify_time"),
  ]

  fileprivate class _StorageClass {
    var _user: Nakama_Api_User? = nil
    var _wallet: String = String()
    var _email: String = String()
    var _devices: [Nakama_Api_AccountDevice] = []
    var _customID: String = String()
    var _verifyTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _wallet = source._wallet
      _email = source._email
      _devices = source._devices
      _customID = source._customID
      _verifyTime = source._verifyTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularStringField(value: &_storage._wallet)
        case 3: try decoder.decodeSingularStringField(value: &_storage._email)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._devices)
        case 5: try decoder.decodeSingularStringField(value: &_storage._customID)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._verifyTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._wallet.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wallet, fieldNumber: 2)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 3)
      }
      if !_storage._devices.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._devices, fieldNumber: 4)
      }
      if !_storage._customID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customID, fieldNumber: 5)
      }
      if let v = _storage._verifyTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Account, rhs: Nakama_Api_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._devices != rhs_storage._devices {return false}
        if _storage._customID != rhs_storage._customID {return false}
        if _storage._verifyTime != rhs_storage._verifyTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountCustom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountCustom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountCustom, rhs: Nakama_Api_AccountCustom) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountDevice, rhs: Nakama_Api_AccountDevice) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountEmail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountEmail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.email)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountEmail, rhs: Nakama_Api_AccountEmail) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountFacebook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountFacebook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountFacebook, rhs: Nakama_Api_AccountFacebook) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountGameCenter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountGameCenter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .standard(proto: "bundle_id"),
    3: .standard(proto: "timestamp_seconds"),
    4: .same(proto: "salt"),
    5: .same(proto: "signature"),
    6: .standard(proto: "public_key_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.playerID)
      case 2: try decoder.decodeSingularStringField(value: &self.bundleID)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timestampSeconds)
      case 4: try decoder.decodeSingularStringField(value: &self.salt)
      case 5: try decoder.decodeSingularStringField(value: &self.signature)
      case 6: try decoder.decodeSingularStringField(value: &self.publicKeyURL)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playerID.isEmpty {
      try visitor.visitSingularStringField(value: self.playerID, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    if self.timestampSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampSeconds, fieldNumber: 3)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 4)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
    }
    if !self.publicKeyURL.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountGameCenter, rhs: Nakama_Api_AccountGameCenter) -> Bool {
    if lhs.playerID != rhs.playerID {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.timestampSeconds != rhs.timestampSeconds {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.publicKeyURL != rhs.publicKeyURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountGoogle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountGoogle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountGoogle, rhs: Nakama_Api_AccountGoogle) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountSteam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountSteam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AccountSteam, rhs: Nakama_Api_AccountSteam) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AddFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddFriendsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      case 2: try decoder.decodeRepeatedStringField(value: &self.usernames)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AddFriendsRequest, rhs: Nakama_Api_AddFriendsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AddGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddGroupUsersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      case 2: try decoder.decodeRepeatedStringField(value: &self.userIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AddGroupUsersRequest, rhs: Nakama_Api_AddGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateCustomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateCustomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountCustom? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateCustomRequest, rhs: Nakama_Api_AuthenticateCustomRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountDevice? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateDeviceRequest, rhs: Nakama_Api_AuthenticateDeviceRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateEmailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateEmailRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountEmail? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateEmailRequest, rhs: Nakama_Api_AuthenticateEmailRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateFacebookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateFacebookRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
    4: .same(proto: "import"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountFacebook? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()
    var _import: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
      _import = source._import
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._import)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
      if let v = _storage._import {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateFacebookRequest, rhs: Nakama_Api_AuthenticateFacebookRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._import != rhs_storage._import {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateGameCenterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateGameCenterRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountGameCenter? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateGameCenterRequest, rhs: Nakama_Api_AuthenticateGameCenterRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateGoogleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateGoogleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountGoogle? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateGoogleRequest, rhs: Nakama_Api_AuthenticateGoogleRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateSteamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateSteamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountSteam? = nil
    var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _username: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _create = source._create
      _username = source._username
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._create)
        case 3: try decoder.decodeSingularStringField(value: &_storage._username)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._create {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_AuthenticateSteamRequest, rhs: Nakama_Api_AuthenticateSteamRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._create != rhs_storage._create {return false}
        if _storage._username != rhs_storage._username {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_BlockFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockFriendsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      case 2: try decoder.decodeRepeatedStringField(value: &self.usernames)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_BlockFriendsRequest, rhs: Nakama_Api_BlockFriendsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ChannelMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "code"),
    4: .standard(proto: "sender_id"),
    5: .same(proto: "username"),
    6: .same(proto: "content"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "update_time"),
    9: .same(proto: "persistent"),
  ]

  fileprivate class _StorageClass {
    var _channelID: String = String()
    var _messageID: String = String()
    var _code: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _senderID: String = String()
    var _username: String = String()
    var _content: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _persistent: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _messageID = source._messageID
      _code = source._code
      _senderID = source._senderID
      _username = source._username
      _content = source._content
      _createTime = source._createTime
      _updateTime = source._updateTime
      _persistent = source._persistent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._channelID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._messageID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._code)
        case 4: try decoder.decodeSingularStringField(value: &_storage._senderID)
        case 5: try decoder.decodeSingularStringField(value: &_storage._username)
        case 6: try decoder.decodeSingularStringField(value: &_storage._content)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._createTime)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._updateTime)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._persistent)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 2)
      }
      if let v = _storage._code {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._senderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderID, fieldNumber: 4)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 5)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 6)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._persistent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ChannelMessage, rhs: Nakama_Api_ChannelMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._senderID != rhs_storage._senderID {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._persistent != rhs_storage._persistent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ChannelMessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelMessageList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "next_cursor"),
    3: .standard(proto: "prev_cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularStringField(value: &self.nextCursor)
      case 3: try decoder.decodeSingularStringField(value: &self.prevCursor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 2)
    }
    if !self.prevCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.prevCursor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ChannelMessageList, rhs: Nakama_Api_ChannelMessageList) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.prevCursor != rhs.prevCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_CreateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "lang_tag"),
    4: .standard(proto: "avatar_url"),
    5: .same(proto: "open"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularStringField(value: &self.langTag)
      case 4: try decoder.decodeSingularStringField(value: &self.avatarURL)
      case 5: try decoder.decodeSingularBoolField(value: &self.`open`)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.langTag.isEmpty {
      try visitor.visitSingularStringField(value: self.langTag, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.`open` != false {
      try visitor.visitSingularBoolField(value: self.`open`, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_CreateGroupRequest, rhs: Nakama_Api_CreateGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.langTag != rhs.langTag {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.`open` != rhs.`open` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteFriendsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      case 2: try decoder.decodeRepeatedStringField(value: &self.usernames)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_DeleteFriendsRequest, rhs: Nakama_Api_DeleteFriendsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_DeleteGroupRequest, rhs: Nakama_Api_DeleteGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteLeaderboardRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteLeaderboardRecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.leaderboardID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_DeleteLeaderboardRecordRequest, rhs: Nakama_Api_DeleteLeaderboardRecordRequest) -> Bool {
    if lhs.leaderboardID != rhs.leaderboardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteNotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteNotificationsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_DeleteNotificationsRequest, rhs: Nakama_Api_DeleteNotificationsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteStorageObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteStorageObjectId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.collection)
      case 2: try decoder.decodeSingularStringField(value: &self.key)
      case 3: try decoder.decodeSingularStringField(value: &self.version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_DeleteStorageObjectId, rhs: Nakama_Api_DeleteStorageObjectId) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteStorageObjectsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.objectIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_DeleteStorageObjectsRequest, rhs: Nakama_Api_DeleteStorageObjectsRequest) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Friend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Friend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _user: Nakama_Api_User? = nil
    var _state: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._state)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._state != 0 {
        try visitor.visitSingularInt32Field(value: _storage._state, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Friend, rhs: Nakama_Api_Friend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Friend.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "FRIEND"),
    2: .same(proto: "INVITE_SENT"),
    3: .same(proto: "INVITE_RECEIVED"),
    4: .same(proto: "BLOCKED"),
  ]
}

extension Nakama_Api_Friends: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Friends"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friends"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.friends)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Friends, rhs: Nakama_Api_Friends) -> Bool {
    if lhs.friends != rhs.friends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GetUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUsersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
    3: .standard(proto: "facebook_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      case 2: try decoder.decodeRepeatedStringField(value: &self.usernames)
      case 3: try decoder.decodeRepeatedStringField(value: &self.facebookIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    if !self.facebookIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.facebookIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_GetUsersRequest, rhs: Nakama_Api_GetUsersRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.facebookIds != rhs.facebookIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "creator_id"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .standard(proto: "lang_tag"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "avatar_url"),
    8: .same(proto: "open"),
    9: .standard(proto: "edge_count"),
    10: .standard(proto: "max_count"),
    11: .standard(proto: "create_time"),
    12: .standard(proto: "update_time"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _creatorID: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _langTag: String = String()
    var _metadata: String = String()
    var _avatarURL: String = String()
    var _open: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _edgeCount: Int32 = 0
    var _maxCount: Int32 = 0
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _creatorID = source._creatorID
      _name = source._name
      _description_p = source._description_p
      _langTag = source._langTag
      _metadata = source._metadata
      _avatarURL = source._avatarURL
      _open = source._open
      _edgeCount = source._edgeCount
      _maxCount = source._maxCount
      _createTime = source._createTime
      _updateTime = source._updateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._creatorID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularStringField(value: &_storage._langTag)
        case 6: try decoder.decodeSingularStringField(value: &_storage._metadata)
        case 7: try decoder.decodeSingularStringField(value: &_storage._avatarURL)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._open)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._edgeCount)
        case 10: try decoder.decodeSingularInt32Field(value: &_storage._maxCount)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._createTime)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._updateTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._creatorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorID, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._langTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._langTag, fieldNumber: 5)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 6)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 7)
      }
      if let v = _storage._open {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._edgeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._edgeCount, fieldNumber: 9)
      }
      if _storage._maxCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxCount, fieldNumber: 10)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Group, rhs: Nakama_Api_Group) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._creatorID != rhs_storage._creatorID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._langTag != rhs_storage._langTag {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._open != rhs_storage._open {return false}
        if _storage._edgeCount != rhs_storage._edgeCount {return false}
        if _storage._maxCount != rhs_storage._maxCount {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_GroupList, rhs: Nakama_Api_GroupList) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupUserList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUserList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groupUsers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupUsers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_GroupUserList, rhs: Nakama_Api_GroupUserList) -> Bool {
    if lhs.groupUsers != rhs.groupUsers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupUserList.GroupUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nakama_Api_GroupUserList.protoMessageName + ".GroupUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _user: Nakama_Api_User? = nil
    var _state: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._state)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._state != 0 {
        try visitor.visitSingularInt32Field(value: _storage._state, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_GroupUserList.GroupUser, rhs: Nakama_Api_GroupUserList.GroupUser) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupUserList.GroupUser.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "SUPERADMIN"),
    2: .same(proto: "ADMIN"),
    3: .same(proto: "MEMBER"),
    4: .same(proto: "JOIN_REQUEST"),
  ]
}

extension Nakama_Api_ImportFacebookFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportFacebookFriendsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "reset"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountFacebook? = nil
    var _reset: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _reset = source._reset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._reset)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._reset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ImportFacebookFriendsRequest, rhs: Nakama_Api_ImportFacebookFriendsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._reset != rhs_storage._reset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_JoinGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_JoinGroupRequest, rhs: Nakama_Api_JoinGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_KickGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KickGroupUsersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      case 2: try decoder.decodeRepeatedStringField(value: &self.userIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_KickGroupUsersRequest, rhs: Nakama_Api_KickGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LeaderboardRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaderboardRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .standard(proto: "owner_id"),
    3: .same(proto: "username"),
    4: .same(proto: "score"),
    5: .same(proto: "subscore"),
    6: .standard(proto: "num_score"),
    7: .same(proto: "metadata"),
    8: .standard(proto: "create_time"),
    9: .standard(proto: "update_time"),
    10: .standard(proto: "expiry_time"),
    11: .same(proto: "rank"),
  ]

  fileprivate class _StorageClass {
    var _leaderboardID: String = String()
    var _ownerID: String = String()
    var _username: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _score: Int64 = 0
    var _subscore: Int64 = 0
    var _numScore: Int32 = 0
    var _metadata: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rank: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leaderboardID = source._leaderboardID
      _ownerID = source._ownerID
      _username = source._username
      _score = source._score
      _subscore = source._subscore
      _numScore = source._numScore
      _metadata = source._metadata
      _createTime = source._createTime
      _updateTime = source._updateTime
      _expiryTime = source._expiryTime
      _rank = source._rank
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._leaderboardID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._ownerID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._username)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._score)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._subscore)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._numScore)
        case 7: try decoder.decodeSingularStringField(value: &_storage._metadata)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._createTime)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._updateTime)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._expiryTime)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._rank)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._leaderboardID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._leaderboardID, fieldNumber: 1)
      }
      if !_storage._ownerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerID, fieldNumber: 2)
      }
      if let v = _storage._username {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._score != 0 {
        try visitor.visitSingularInt64Field(value: _storage._score, fieldNumber: 4)
      }
      if _storage._subscore != 0 {
        try visitor.visitSingularInt64Field(value: _storage._subscore, fieldNumber: 5)
      }
      if _storage._numScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numScore, fieldNumber: 6)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 7)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._expiryTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._rank != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rank, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_LeaderboardRecord, rhs: Nakama_Api_LeaderboardRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._leaderboardID != rhs_storage._leaderboardID {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._subscore != rhs_storage._subscore {return false}
        if _storage._numScore != rhs_storage._numScore {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._expiryTime != rhs_storage._expiryTime {return false}
        if _storage._rank != rhs_storage._rank {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LeaderboardRecordList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaderboardRecordList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
    2: .standard(proto: "owner_records"),
    3: .standard(proto: "next_cursor"),
    4: .standard(proto: "prev_cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.records)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ownerRecords)
      case 3: try decoder.decodeSingularStringField(value: &self.nextCursor)
      case 4: try decoder.decodeSingularStringField(value: &self.prevCursor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    if !self.ownerRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerRecords, fieldNumber: 2)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 3)
    }
    if !self.prevCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.prevCursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_LeaderboardRecordList, rhs: Nakama_Api_LeaderboardRecordList) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs.ownerRecords != rhs.ownerRecords {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.prevCursor != rhs.prevCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LeaveGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaveGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_LeaveGroupRequest, rhs: Nakama_Api_LeaveGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LinkFacebookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkFacebookRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    4: .same(proto: "import"),
  ]

  fileprivate class _StorageClass {
    var _account: Nakama_Api_AccountFacebook? = nil
    var _import: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _import = source._import
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._import)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._import {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_LinkFacebookRequest, rhs: Nakama_Api_LinkFacebookRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._import != rhs_storage._import {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListChannelMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelMessagesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "limit"),
    3: .same(proto: "forward"),
    4: .same(proto: "cursor"),
  ]

  fileprivate class _StorageClass {
    var _channelID: String = String()
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _forward: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _cursor: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _limit = source._limit
      _forward = source._forward
      _cursor = source._cursor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._channelID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._limit)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._forward)
        case 4: try decoder.decodeSingularStringField(value: &_storage._cursor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 1)
      }
      if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._forward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListChannelMessagesRequest, rhs: Nakama_Api_ListChannelMessagesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._forward != rhs_storage._forward {return false}
        if _storage._cursor != rhs_storage._cursor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGroupsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cursor"),
    3: .same(proto: "limit"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _cursor: String = String()
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _cursor = source._cursor
      _limit = source._limit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._cursor)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._limit)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 2)
      }
      if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListGroupsRequest, rhs: Nakama_Api_ListGroupsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._cursor != rhs_storage._cursor {return false}
        if _storage._limit != rhs_storage._limit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGroupUsersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListGroupUsersRequest, rhs: Nakama_Api_ListGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListLeaderboardRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLeaderboardRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .standard(proto: "owner_ids"),
    3: .same(proto: "limit"),
    4: .same(proto: "cursor"),
  ]

  fileprivate class _StorageClass {
    var _leaderboardID: String = String()
    var _ownerIds: [String] = []
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _cursor: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leaderboardID = source._leaderboardID
      _ownerIds = source._ownerIds
      _limit = source._limit
      _cursor = source._cursor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._leaderboardID)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._ownerIds)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._limit)
        case 4: try decoder.decodeSingularStringField(value: &_storage._cursor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._leaderboardID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._leaderboardID, fieldNumber: 1)
      }
      if !_storage._ownerIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ownerIds, fieldNumber: 2)
      }
      if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListLeaderboardRecordsRequest, rhs: Nakama_Api_ListLeaderboardRecordsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._leaderboardID != rhs_storage._leaderboardID {return false}
        if _storage._ownerIds != rhs_storage._ownerIds {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._cursor != rhs_storage._cursor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListMatchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMatchesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .same(proto: "authoritative"),
    3: .same(proto: "label"),
    4: .standard(proto: "min_size"),
    5: .standard(proto: "max_size"),
  ]

  fileprivate class _StorageClass {
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _authoritative: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _label: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _minSize: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _maxSize: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _limit = source._limit
      _authoritative = source._authoritative
      _label = source._label
      _minSize = source._minSize
      _maxSize = source._maxSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._limit)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._authoritative)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._label)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._minSize)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._maxSize)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._authoritative {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._label {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._minSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._maxSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListMatchesRequest, rhs: Nakama_Api_ListMatchesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._authoritative != rhs_storage._authoritative {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._minSize != rhs_storage._minSize {return false}
        if _storage._maxSize != rhs_storage._maxSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListNotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListNotificationsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .standard(proto: "cacheable_cursor"),
  ]

  fileprivate class _StorageClass {
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _cacheableCursor: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _limit = source._limit
      _cacheableCursor = source._cacheableCursor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._limit)
        case 2: try decoder.decodeSingularStringField(value: &_storage._cacheableCursor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._cacheableCursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cacheableCursor, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListNotificationsRequest, rhs: Nakama_Api_ListNotificationsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._cacheableCursor != rhs_storage._cacheableCursor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListStorageObjectsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "collection"),
    3: .same(proto: "limit"),
    4: .same(proto: "cursor"),
  ]

  fileprivate class _StorageClass {
    var _userID: String = String()
    var _collection: String = String()
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _cursor: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userID = source._userID
      _collection = source._collection
      _limit = source._limit
      _cursor = source._cursor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._userID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._collection)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._limit)
        case 4: try decoder.decodeSingularStringField(value: &_storage._cursor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 1)
      }
      if !_storage._collection.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collection, fieldNumber: 2)
      }
      if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListStorageObjectsRequest, rhs: Nakama_Api_ListStorageObjectsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._cursor != rhs_storage._cursor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListUserGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUserGroupsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ListUserGroupsRequest, rhs: Nakama_Api_ListUserGroupsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Match"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "authoritative"),
    3: .same(proto: "label"),
    4: .same(proto: "size"),
  ]

  fileprivate class _StorageClass {
    var _matchID: String = String()
    var _authoritative: Bool = false
    var _label: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _size: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _matchID = source._matchID
      _authoritative = source._authoritative
      _label = source._label
      _size = source._size
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._matchID)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._authoritative)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._label)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._size)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._matchID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._matchID, fieldNumber: 1)
      }
      if _storage._authoritative != false {
        try visitor.visitSingularBoolField(value: _storage._authoritative, fieldNumber: 2)
      }
      if let v = _storage._label {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt32Field(value: _storage._size, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Match, rhs: Nakama_Api_Match) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._matchID != rhs_storage._matchID {return false}
        if _storage._authoritative != rhs_storage._authoritative {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._size != rhs_storage._size {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_MatchList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MatchList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matches"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matches)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_MatchList, rhs: Nakama_Api_MatchList) -> Bool {
    if lhs.matches != rhs.matches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "subject"),
    3: .same(proto: "content"),
    4: .same(proto: "code"),
    5: .standard(proto: "sender_id"),
    6: .standard(proto: "create_time"),
    7: .same(proto: "persistent"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _subject: String = String()
    var _content: String = String()
    var _code: Int32 = 0
    var _senderID: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _persistent: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _subject = source._subject
      _content = source._content
      _code = source._code
      _senderID = source._senderID
      _createTime = source._createTime
      _persistent = source._persistent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._subject)
        case 3: try decoder.decodeSingularStringField(value: &_storage._content)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._code)
        case 5: try decoder.decodeSingularStringField(value: &_storage._senderID)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._createTime)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._persistent)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._subject.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subject, fieldNumber: 2)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 3)
      }
      if _storage._code != 0 {
        try visitor.visitSingularInt32Field(value: _storage._code, fieldNumber: 4)
      }
      if !_storage._senderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderID, fieldNumber: 5)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._persistent != false {
        try visitor.visitSingularBoolField(value: _storage._persistent, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Notification, rhs: Nakama_Api_Notification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._senderID != rhs_storage._senderID {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._persistent != rhs_storage._persistent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_NotificationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
    2: .standard(proto: "cacheable_cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.notifications)
      case 2: try decoder.decodeSingularStringField(value: &self.cacheableCursor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    if !self.cacheableCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheableCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_NotificationList, rhs: Nakama_Api_NotificationList) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.cacheableCursor != rhs.cacheableCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_PromoteGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromoteGroupUsersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      case 2: try decoder.decodeRepeatedStringField(value: &self.userIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_PromoteGroupUsersRequest, rhs: Nakama_Api_PromoteGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ReadStorageObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadStorageObjectId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.collection)
      case 2: try decoder.decodeSingularStringField(value: &self.key)
      case 3: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ReadStorageObjectId, rhs: Nakama_Api_ReadStorageObjectId) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ReadStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadStorageObjectsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.objectIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_ReadStorageObjectsRequest, rhs: Nakama_Api_ReadStorageObjectsRequest) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Rpc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rpc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "payload"),
    3: .standard(proto: "http_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.payload)
      case 3: try decoder.decodeSingularStringField(value: &self.httpKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    if !self.httpKey.isEmpty {
      try visitor.visitSingularStringField(value: self.httpKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Rpc, rhs: Nakama_Api_Rpc) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.httpKey != rhs.httpKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
    2: .same(proto: "token"),
    3: .standard(proto: "udp_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.created)
      case 2: try decoder.decodeSingularStringField(value: &self.token)
      case 3: try decoder.decodeSingularStringField(value: &self.udpToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.udpToken.isEmpty {
      try visitor.visitSingularStringField(value: self.udpToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Session, rhs: Nakama_Api_Session) -> Bool {
    if lhs.created != rhs.created {return false}
    if lhs.token != rhs.token {return false}
    if lhs.udpToken != rhs.udpToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "value"),
    5: .same(proto: "version"),
    6: .standard(proto: "permission_read"),
    7: .standard(proto: "permission_write"),
    8: .standard(proto: "create_time"),
    9: .standard(proto: "update_time"),
  ]

  fileprivate class _StorageClass {
    var _collection: String = String()
    var _key: String = String()
    var _userID: String = String()
    var _value: String = String()
    var _version: String = String()
    var _permissionRead: Int32 = 0
    var _permissionWrite: Int32 = 0
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collection = source._collection
      _key = source._key
      _userID = source._userID
      _value = source._value
      _version = source._version
      _permissionRead = source._permissionRead
      _permissionWrite = source._permissionWrite
      _createTime = source._createTime
      _updateTime = source._updateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._collection)
        case 2: try decoder.decodeSingularStringField(value: &_storage._key)
        case 3: try decoder.decodeSingularStringField(value: &_storage._userID)
        case 4: try decoder.decodeSingularStringField(value: &_storage._value)
        case 5: try decoder.decodeSingularStringField(value: &_storage._version)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._permissionRead)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._permissionWrite)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._createTime)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._updateTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._collection.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collection, fieldNumber: 1)
      }
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 2)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 3)
      }
      if !_storage._value.isEmpty {
        try visitor.visitSingularStringField(value: _storage._value, fieldNumber: 4)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      if _storage._permissionRead != 0 {
        try visitor.visitSingularInt32Field(value: _storage._permissionRead, fieldNumber: 6)
      }
      if _storage._permissionWrite != 0 {
        try visitor.visitSingularInt32Field(value: _storage._permissionWrite, fieldNumber: 7)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_StorageObject, rhs: Nakama_Api_StorageObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._permissionRead != rhs_storage._permissionRead {return false}
        if _storage._permissionWrite != rhs_storage._permissionWrite {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjectAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageObjectAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .same(proto: "version"),
    4: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.collection)
      case 2: try decoder.decodeSingularStringField(value: &self.key)
      case 3: try decoder.decodeSingularStringField(value: &self.version)
      case 4: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_StorageObjectAck, rhs: Nakama_Api_StorageObjectAck) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.version != rhs.version {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjectAcks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageObjectAcks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.acks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_StorageObjectAcks, rhs: Nakama_Api_StorageObjectAcks) -> Bool {
    if lhs.acks != rhs.acks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageObjects"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.objects)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_StorageObjects, rhs: Nakama_Api_StorageObjects) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjectList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageObjectList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objects"),
    2: .same(proto: "cursor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.objects)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_StorageObjectList, rhs: Nakama_Api_StorageObjectList) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UpdateAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "avatar_url"),
    4: .standard(proto: "lang_tag"),
    5: .same(proto: "location"),
    6: .same(proto: "timezone"),
  ]

  fileprivate class _StorageClass {
    var _username: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _displayName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _avatarURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _langTag: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _location: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _timezone: SwiftProtobuf.Google_Protobuf_StringValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _username = source._username
      _displayName = source._displayName
      _avatarURL = source._avatarURL
      _langTag = source._langTag
      _location = source._location
      _timezone = source._timezone
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._username)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._displayName)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._avatarURL)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._langTag)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._location)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._timezone)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._username {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._displayName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._avatarURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._langTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._timezone {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_UpdateAccountRequest, rhs: Nakama_Api_UpdateAccountRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._username != rhs_storage._username {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._langTag != rhs_storage._langTag {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UpdateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "lang_tag"),
    5: .standard(proto: "avatar_url"),
    6: .same(proto: "open"),
  ]

  fileprivate class _StorageClass {
    var _groupID: String = String()
    var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _description_p: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _langTag: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _avatarURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _open: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupID = source._groupID
      _name = source._name
      _description_p = source._description_p
      _langTag = source._langTag
      _avatarURL = source._avatarURL
      _open = source._open
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._groupID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._langTag)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._avatarURL)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._open)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 1)
      }
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._description_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._langTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._avatarURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._open {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_UpdateGroupRequest, rhs: Nakama_Api_UpdateGroupRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._langTag != rhs_storage._langTag {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._open != rhs_storage._open {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "username"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "avatar_url"),
    5: .standard(proto: "lang_tag"),
    6: .same(proto: "location"),
    7: .same(proto: "timezone"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "facebook_id"),
    10: .standard(proto: "google_id"),
    11: .standard(proto: "gamecenter_id"),
    12: .standard(proto: "steam_id"),
    13: .same(proto: "online"),
    14: .standard(proto: "edge_count"),
    15: .standard(proto: "create_time"),
    16: .standard(proto: "update_time"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _username: String = String()
    var _displayName: String = String()
    var _avatarURL: String = String()
    var _langTag: String = String()
    var _location: String = String()
    var _timezone: String = String()
    var _metadata: String = String()
    var _facebookID: String = String()
    var _googleID: String = String()
    var _gamecenterID: String = String()
    var _steamID: String = String()
    var _online: Bool = false
    var _edgeCount: Int32 = 0
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _username = source._username
      _displayName = source._displayName
      _avatarURL = source._avatarURL
      _langTag = source._langTag
      _location = source._location
      _timezone = source._timezone
      _metadata = source._metadata
      _facebookID = source._facebookID
      _googleID = source._googleID
      _gamecenterID = source._gamecenterID
      _steamID = source._steamID
      _online = source._online
      _edgeCount = source._edgeCount
      _createTime = source._createTime
      _updateTime = source._updateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._username)
        case 3: try decoder.decodeSingularStringField(value: &_storage._displayName)
        case 4: try decoder.decodeSingularStringField(value: &_storage._avatarURL)
        case 5: try decoder.decodeSingularStringField(value: &_storage._langTag)
        case 6: try decoder.decodeSingularStringField(value: &_storage._location)
        case 7: try decoder.decodeSingularStringField(value: &_storage._timezone)
        case 8: try decoder.decodeSingularStringField(value: &_storage._metadata)
        case 9: try decoder.decodeSingularStringField(value: &_storage._facebookID)
        case 10: try decoder.decodeSingularStringField(value: &_storage._googleID)
        case 11: try decoder.decodeSingularStringField(value: &_storage._gamecenterID)
        case 12: try decoder.decodeSingularStringField(value: &_storage._steamID)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._online)
        case 14: try decoder.decodeSingularInt32Field(value: &_storage._edgeCount)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._createTime)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._updateTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 2)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if !_storage._langTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._langTag, fieldNumber: 5)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 6)
      }
      if !_storage._timezone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timezone, fieldNumber: 7)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 8)
      }
      if !_storage._facebookID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._facebookID, fieldNumber: 9)
      }
      if !_storage._googleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._googleID, fieldNumber: 10)
      }
      if !_storage._gamecenterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gamecenterID, fieldNumber: 11)
      }
      if !_storage._steamID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._steamID, fieldNumber: 12)
      }
      if _storage._online != false {
        try visitor.visitSingularBoolField(value: _storage._online, fieldNumber: 13)
      }
      if _storage._edgeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._edgeCount, fieldNumber: 14)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_User, rhs: Nakama_Api_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._langTag != rhs_storage._langTag {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._facebookID != rhs_storage._facebookID {return false}
        if _storage._googleID != rhs_storage._googleID {return false}
        if _storage._gamecenterID != rhs_storage._gamecenterID {return false}
        if _storage._steamID != rhs_storage._steamID {return false}
        if _storage._online != rhs_storage._online {return false}
        if _storage._edgeCount != rhs_storage._edgeCount {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UserGroupList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserGroupList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.userGroups)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userGroups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_UserGroupList, rhs: Nakama_Api_UserGroupList) -> Bool {
    if lhs.userGroups != rhs.userGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UserGroupList.UserGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nakama_Api_UserGroupList.protoMessageName + ".UserGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _group: Nakama_Api_Group? = nil
    var _state: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._group)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._state)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._state != 0 {
        try visitor.visitSingularInt32Field(value: _storage._state, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_UserGroupList.UserGroup, rhs: Nakama_Api_UserGroupList.UserGroup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UserGroupList.UserGroup.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "SUPERADMIN"),
    2: .same(proto: "ADMIN"),
    3: .same(proto: "MEMBER"),
    4: .same(proto: "JOIN_REQUEST"),
  ]
}

extension Nakama_Api_Users: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Users"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.users)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_Users, rhs: Nakama_Api_Users) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteLeaderboardRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteLeaderboardRecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .same(proto: "record"),
  ]

  fileprivate class _StorageClass {
    var _leaderboardID: String = String()
    var _record: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leaderboardID = source._leaderboardID
      _record = source._record
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._leaderboardID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._record)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._leaderboardID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._leaderboardID, fieldNumber: 1)
      }
      if let v = _storage._record {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_WriteLeaderboardRecordRequest, rhs: Nakama_Api_WriteLeaderboardRecordRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._leaderboardID != rhs_storage._leaderboardID {return false}
        if _storage._record != rhs_storage._record {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nakama_Api_WriteLeaderboardRecordRequest.protoMessageName + ".LeaderboardRecordWrite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "subscore"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.score)
      case 2: try decoder.decodeSingularInt64Field(value: &self.subscore)
      case 3: try decoder.decodeSingularStringField(value: &self.metadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularInt64Field(value: self.score, fieldNumber: 1)
    }
    if self.subscore != 0 {
      try visitor.visitSingularInt64Field(value: self.subscore, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite, rhs: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.subscore != rhs.subscore {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteStorageObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteStorageObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
    4: .same(proto: "version"),
    5: .standard(proto: "permission_read"),
    6: .standard(proto: "permission_write"),
  ]

  fileprivate class _StorageClass {
    var _collection: String = String()
    var _key: String = String()
    var _value: String = String()
    var _version: String = String()
    var _permissionRead: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _permissionWrite: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collection = source._collection
      _key = source._key
      _value = source._value
      _version = source._version
      _permissionRead = source._permissionRead
      _permissionWrite = source._permissionWrite
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._collection)
        case 2: try decoder.decodeSingularStringField(value: &_storage._key)
        case 3: try decoder.decodeSingularStringField(value: &_storage._value)
        case 4: try decoder.decodeSingularStringField(value: &_storage._version)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._permissionRead)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._permissionWrite)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._collection.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collection, fieldNumber: 1)
      }
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 2)
      }
      if !_storage._value.isEmpty {
        try visitor.visitSingularStringField(value: _storage._value, fieldNumber: 3)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 4)
      }
      if let v = _storage._permissionRead {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._permissionWrite {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_WriteStorageObject, rhs: Nakama_Api_WriteStorageObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._permissionRead != rhs_storage._permissionRead {return false}
        if _storage._permissionWrite != rhs_storage._permissionWrite {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteStorageObjectsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.objects)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nakama_Api_WriteStorageObjectsRequest, rhs: Nakama_Api_WriteStorageObjectsRequest) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
